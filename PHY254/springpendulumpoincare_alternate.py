#!/Users/dchandan/Library/Enthought/Canopy_64bit/User/bin/python

from pylab import *
from scipy.integrate import odeint
from scipy.interpolate import interp1d
from numpy import *



def rhs(state,t):
    """
    This is our typical RHS function. Code in the missing sections.
    """
    x  = ????
    y  = ????
    vx = ????
    vy = ????
    
    #Our EOM's
    A      = (1-sigma)/sigma
    vx_dot = ????
    vy_dot = ????
    
    return array([????, ????, ????, ????])



def process_poincare(solution, times): 
    """
    Now this function actually produces the poincare section data. What this does is
    go through the solution array (generated by odeint) and pick out the points that
    lie on the poincare section. 
    ARGUMENTS:
        solution - array of odeint solution
        times    - 1D numpy array of integration times used by odeint
    RETURNS:
        2D array of data. The number of rows correspond to the number of poincare 
        points, and the two columns correspond to the x and vx for. 
    """  
    poincaresection = []
    addtopoincaresection = poincaresection.append
    for i in range(1, solution.shape[0]):
        # NOTE: I can do i-1 because my loop is starting at 1, not 0. 
        prevx  = solution[i-1, 0]
        prevy  = solution[i-1, 1]
        prevvx = solution[i-1, 2]
        prevvy = solution[i-1, 3]
        prevt  = times[i-1]
        
        x  = solution[i, 0]
        y  = solution[i, 1]
        vx = solution[i, 2]
        vy = solution[i, 3]
        t  = times[i]
        
        #We only want to consider points where vy>0
        if( vy > 0.0):
    		# Our poincare surface is at y=0, so if y is now >0 and it was <0
    		# in the last timestep (prevy<0) then we know that sometime between
    		# the last timestep and now the solution had to cross the y=0 surface
            if ((y > 0.0) and (prevy < 0.0)):
                # To figure out exactly when it crossed y=0 we are going to use the interp1d
                # function built into python.
                interpx  = [prevx,  x]
                interpy  = [prevy,  y]
                interpvx = [prevvx, vx]
                interpvy = [prevvy, vy]
                interpt  = [prevt,  t]
                
                fy  = interp1d(interpy, interpt,  kind='linear')
                fx  = interp1d(interpt, interpx,  kind='linear')
                fvx = interp1d(interpt, interpvx, kind='linear')
                fvy = interp1d(interpt, interpvy, kind='linear')
                
                #We figure out what time the solution crossed the y=0.0 surface
                crossingtime = fy(0.0)
                
                # Then figure out what all the other variables were at that time
                poincarepointx  = fx(crossingtime)
                poincarepointvx = fvx(crossingtime)
                
                #We are interested in an x vs vx plot, so we add that point to our poincare section array
                addtopoincaresection([poincarepointx, poincarepointvx])
        
    return array(poincaresection)
#=====================================================================================


# Define the start-time, end-time and number of points here
start = 0.0
end   = 17000.0
# NOTE: those of you who have seen the previous code will note that the number
# of points here is larger than in the older code. This is NOT an error. Leave
# these numbers as they are. 
num   = 80000

# Define system parameters here
sigma = 0.25


# Define initial conditions here
E     = 1.0
x0    = -0.1
vx0   = 1
y0    = 0.
vy0   = sqrt( 2*E-2*y0 - pow(vx0,2) - (1/sigma)*pow(sqrt(pow(x0,2)+pow(1-y0,2))-1+sigma,2) )



times   = linspace(start, end, num)
initial = array([x0, y0, vx0, vy0])



print("Start time    : {0:4.2f}".format(start))
print("End time      : {0:4.2f}".format(end))
print("Timesteps     : {0:d}".format(num))
print("Sigma         : {0:4.2f}".format(sigma))
print("Total Energy  : {0:4.2f}".format(E))
print("Initial state : [{0:3.1f}, {1:3.1f}, {2:3.1f}, {3:3.1f}]".format(x0, y0, vx0, vy0))


print("Solving the Rossler system ...")
solution = odeint(rhs, initial, times)

print("Processing intersection points ...")
poincaresection = process_poincare(solution, times)

print ("Plotting poincare section with %d points ..." % (poincaresection.shape[0]))

figure()
scatter(poincaresection[:,0], poincaresection[:,1], c='k', s=0.5, marker='.')
xlabel(r'$x$', fontsize=20)
ylabel(r'$v_x$', fontsize=20)
title(r"$E=%3.1f,\ \sigma=%4.2f$" % (E, sigma), fontsize=20)
# savefig('****.pdf')
show()